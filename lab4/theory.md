# Атрибутные транслирующие грамматики

**Опр**.: Синтаксически управляемой определением (СУ) -- КС грамматика с атрибутами и правилами, где атрибуты связаны с грамматическими символами, причем $X \in {\Sigma, T}$  , а правила с продукциями (P).

**Опр**. СУ трансляция -- это трансляция, в которой при процессе разбора входная цепочка сразу выполняется какие-то действия без использования промежуточных представлений.

**Опр**. Атрибут - это некоторые дополнительные данные, ассоциируемые с грамматическим символом  Х, если Х представляет собой символ а один из его атрибутов, то значит $а$ в некотором узле дерева разбора помеченным Х записывается как X.a.

**Опр** Дерево разбора, в каждом узле которого  атрибут уже вычислен , называется  аннотированным, а процесс вычисления -- аннотирование дерева разбора. 

**Опр**. Транслирующий символ -- не терминал, который в момент раскрытия выполняет связанное с ним действие. Действия пишутся в фигурных скобках рядом с транслирующим символом.

**Пример**: 

| Грамматика | семантические правила |
| ---------- | --------------------- |
| А -> В     | A_s = B_i             |
|            | B_i = A_{s+1}         |
 
**Опр** Атрибут, значение которого зависит от значения атрибутов детей узла или других атрибутов этого узла называется синтезируемым.

**Опр** Грамматика называется S-аттрибутивной , если с атрибутами выполняются только операции присвоения значения других атрибутов, а внутри транслирующих символов происходит обращение к атрибутами этого транспортирующего символа. В грамматике используются только синтезируемые атрибуты. 

Т.е. дерево разбора будет аннотированно путем выполнения синтаксический правил снизу-вверх: от листьев к корню.

**Пример**:

| Продукция:                            | Семантическое правило |
| ------------------------------------- | --------------------- |
| S->E                                  | S.val = E.val         |
| ------------------------------------- | --------------------- |
| E_0 -> E_1 + T { ADD.res = op1 + op2} | ADD.op1 = E_1.val     |
|                                       | ADD.op2 = T.val       |
|                                       | E.val = Add.Val       |
| ------------------------------------- | --------------------- |
| E -> T                                | E.val = T.val         |
| ------------------------------------- | --------------------- |
| T_0 -> T_1 + F {MULL.res = op1+ op2}  | MUL.op1 = T_1.val     |
|                                       | MUL.op2 = T_2.val     |
|                                       | T_0.val = Mul.res     |
| ------------------------------------- | --------------------- |
| T-> F                                 | T.val = F.val         |
| ------------------------------------- | --------------------- |
| F -> n                                | F.val = n.val         |
| ------------------------------------- | --------------------- |
| F -> ( E )                            | F.val = E.val         |
| ------------------------------------- | --------------------- |

![Attachment-2024-04-27](/Attachment-2024-04-27.jpg)



 **Опр**. Атрибут , значение которого зависит от значения атрибутов братьев узлов или атрибутов родителей, называется наследуемым.
 
 **Опр**: Грамматика называется L-атрибутивной , если значения наследуемых атрибутов зависят только от родителей и братьев слева. 
 
 
 **Пример**
 Грамматика объявления переменных
 D -> T L
 T -> int | real 
 L -> L, ID | ID
 
| Продукция                                    | Семантические правила  |
| -------------------------------------------- | ---------------------- |
| D -> T L                                     | L.type T.type          |
| T -> int                                     | T.type = int           |
| T -> real                                    | T.type = real          |
| L_0 -> L_1 , ID. {ENTRY.addtype(key, value)} | Entry.key = id .text   |
|                                              | Entry.value = L_0.type |
| L -> ID  {ENTRY.addtype(key, value)}         | Entry.key = id .text   |
|                                              | Entry.value = L.type   |