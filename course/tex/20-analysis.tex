\chapter{Аналитический раздел}

\section{Инфраструктура построения компилятора}

Инфраструктура построения компилятора обычно состоит из трех основных компонентов: Frontend, Middle-end и Backend.
На рисунке~\ref{fig:compiller-layers} представлена схема слоев инфраструктуры компилятора.

\begin{figure}[h]
    \centering

    \includesvg[width=\textwidth]{plantuml/export/compiller-layers}

    \caption{Слои компилятора}
    \label{fig:compiller-layers}
\end{figure}


Frontend компилятора отвечает за анализ исходного кода программы.
Данный компонент обычно включает в себя препроцессор, лексические, синтаксические и семантические анализаторы, генераторы промежуточного представления.

Middle-end выполняет оптимизации и преобразования программы, основанные на промежуточном представлении, полученном от Frontend.
Данный компонент может включать в себя различные оптимизации, такие как удаление недостижимого кода, упрощение выражений, встраивание функций.
Middle-end также может выполнять анализ зависимостей, определение времени жизни переменных и иные анализы, необходимые для оптимизации программы.
После завершения работы Middle-end создает промежуточное представление программы, которое будет передано Backend для генерации машинного кода.

Backend компилятора отвечает за генерацию машинного кода на основе промежуточного представления программы, полученного от Middle-end.
Данный компонент анализирует промежуточное представление и генерирует соответствующий машинный код для целевой архитектуры.
Backend также может выполнять дополнительные оптимизации, специфичные для целевой архитектуры, такие как распределение регистров и сокращение размера кода.
После завершения работы Backend генерирует исполняемый файл, который может быть запущен на целевой аппаратной платформе~\cite{wilhelm1995compiler}.

\subsection{Лексические и синтаксические анализаторы}

Лексический и синтаксический анализаторы являются ключевыми компонентами компилятора, ответственными за преобразование исходного кода программы в промежуточное представление, которое необходимо для дальнейшей обработки.

Лексический анализатор (лексер) преобразует поток символов исходного кода программы в последовательность токенов.
Токены представляют собой лексемы, или элементы языка, такие как идентификаторы, ключевые слова, операторы, числа и строки.
Лексический анализатор также может игнорировать комментарии и обрабатывать различные форматирования, такие как пробелы и переводы строк.

Синтаксический анализатор (парсер) анализирует структуру программы на основе последовательности токенов, созданных лексическим анализатором.
Он использует грамматику языка программирования для определения правил, по которым могут комбинироваться токены, чтобы создавать корректные конструкции языка.
Синтаксический анализатор создает синтаксическое дерево (дерево разбора), которое представляет собой иерархическое представление структуры программы~\cite{aho1978synt, kandomski2018lexers}.


Существует несколько подходов для реализации лексического и синтаксического анализаторов:
\begin{itemize}
    \item с использованием стандартных алгоритмов анализа;
    \item с привлечением готовых инструментов генерации.
\end{itemize}

\subsubsection*{Методы лексического анализа}


LL-анализатор -- это метод разбора для определенного подмножества контекстно-свободных грамматик, которые известны как LL-грамматики.
Буква L в термине <<LL-анализатор>> обозначает, что входная строка обрабатывается с начала до конца и генерируется ее левосторонний вывод.
Если анализатор использует предварительный просмотр на k токенов при разборе входных данных, его называют LL(k)-анализатор.
LL(1)-анализаторы очень широко распространены, так как они просматривают входные данные только на один шаг вперед, чтобы определить, какое грамматическое правило применить.

LR-анализатор читает входной поток слева направо и создает самую правую продукцию контекстно-свободной грамматики.
Термин LR(k)-анализатор также используется.
Здесь k означает количество непрочитанных символов предварительного просмотра во входном потоке, на основе которых принимаются решения в процессе анализа.
Синтаксис многих языков программирования определяется грамматикой LR(1) или аналогичной грамматикой.
LR-анализатор обрабатывает код сверху вниз, поскольку он пытается создать продукцию верхнего уровня грамматики из листьев~\cite{sippu2013parsing}.


\subsubsection*{Генераторы лексических и синтаксических анализаторов}


Lex~\cite{lesk1975lex} -- стандартный инструмент для получения лексических анализаторов в операционных системах Unix, обычно используется совместно с генератором синтаксических анализаторов Yacc.
В результате обработки входного потока получается исходный файл на языке Си.
Flex~(Fast Lexical Analyzer)~\cite{flexdoc} заменяет Lex в системах на базе пакетов GNU и имеет аналогичную функциональность.
Bison -- аналогичный YACC генератор для GNU систем.

ANTLR (ANother Tool for Language Recognition) -- генератор лексических и синтаксических анализаторов, позволяет создавать анализаторы на многих языках программирования.
Он также позволяет строить и обходить деревья синтаксического анализа с использованием паттернов посетитель или слушатель~\cite{parr2013definitive}.

Сосо/R -- инструмент генерации компиляторов или интерпретаторов языка.
Coco/R изначально разрабатывался в ETHZ и перешел вместе с Ханспетером Мессенбеком в Университет Линца.
Coco/R распространяется на условиях слегка смягченной GNU General Public License~\cite{cocordoc}.




\subsubsection*{Сравнительный анализ генераторов}


В таблице~\ref{tab:parser-analis} представлен сравнительный анализ анализаторов исходного кода.

\begin{table}[]
    \centering
    \caption{Сравнение генераторов анализаторов исходного кода}
    \label{tab:parser-analis}
    \begin{tabular}{|p{4.5cm}|p{3cm}|p{3cm}|p{4.5cm}|}
        \hline
        Критерии & ANTLR & Flex + Bison & Coco/R \\ \hline
        Алгоритм лексера & ДКА & ДКА & ДКА\\ \hline
        Алгоритм парсера & LL(*) & LR & LL(1) \\ \hline
        Поддерживаемые языки программирования & C\#, Java, Python, JavaScript, C++, Swift, Go, PHP & C, C++, Java & C, C++, C\#, F\#, Java, Ada, Object Pascal, Delphi, Modula-2, Oberon, Ruby, Swift, Unicon, Visual Basic \\ \hline
        Входная грамматика & РБНФ & Yacc & РБНФ \\ \hline
        Интеграция с инструментами разработки & IntelliJ IDEA, Eclipse и другие & Нет & Нет \\ \hline
        Наличие встроенных инструментов отладки & Да & Нет & Нет \\ \hline
        Лицензия использования & BSD-подобная & GNU GPL & GNU GPL\\ \hline
    \end{tabular}
\end{table}


Все три инструмента предлагают различные подходы к синтаксическому анализу текста.
Данные инструменты могут работать с РБНФ грамматиками.
ANTLR имеет преимущество в виде поддержки интегрированных инструментов разработки, таких как IntelliJ IDEA и Eclipse.
С точки зрения лицензии, ANTLR является одним из наиболее гибких инструментов, предоставляя BSD-подобную лицензию на использование.




\subsection{Генерация исполняемого кода}


Инструменты генерации исполняемого кода играют ключевую роль в процессе компиляции программ.
Они отвечают за трансляцию абстрактного синтаксического дерева (AST-дерева) или промежуточного представления (IR) программы в исполняемый машинный код или байткод, который может быть исполнен на целевой аппаратуре или виртуальной машине.


Генерация машинного кода относится к процессу преобразования исходного кода программы в низкоуровневый бинарный код, который может быть исполнен непосредственно аппаратурой процессора.
Генерация машинного кода приводит к созданию исполняемых файлов, которые могут быть непосредственно запущены на целевой платформе без дополнительной обработки.

Виртуальная машина -- это абстрактная вычислительная машина, которая исполняет программный код, представленный в виде некоторого промежуточного представления -- байткода.
Виртуальные машины обычно используются для исполнения программного кода, который был предварительно скомпилирован в промежуточное представление, а не в машинный код конкретной архитектуры процессора~\cite{appel1989runtime}.
Примерами виртуальных машин являются Java Virtual Machine (JVM), Common Language Runtime (CLR), и V8 (WASM) для веб-приложений .



LLVM (Low Level Virtual Machine) представляет собой инфраструктуру для разработки компиляторов и связанных инструментов.
Он включает в себя мощный оптимизатор и генератор машинного кода, который может работать с различными архитектурами процессоров.
LLVM генерирует промежуточное представление LLVM IR, которое затем транслируется в машинный код для целевой архитектуры.
Он также поддерживает генерацию байткода для виртуальных машин, таких как JVM и WASM~\cite{llvm_ofsite}.

GCC (GNU Compiler Collection) - это другая широко используемая инфраструктура для разработки компиляторов.
В качестве промежуточного представления используется GIMPLE.
GCC генерирует машинный код для различных архитектур процессоров и поддерживает генерацию байткода для некоторых виртуальных машин~\cite{vichare2008conceptual}.

Java ASM (Java bytecode manipulation framework) - это библиотека на языке Java, предназначенная для манипулирования байткодом Java.
Ее можно использовать для модификации существующих классов или для динамической генерации классов непосредственно в форме байткода.
ASM предоставляет некоторые распространенные преобразования байт-кода и алгоритмы анализа, на основе которых могут быть созданы пользовательские сложные преобразования и инструменты анализа кода.
ASM предлагает функциональность, аналогичную другим фреймворкам байт-кода Java, но ориентирован на производительность.


ILAsm (Intermediate Language Assembler) -- это инструмент для создания исполняемых программ для платформы CLR (Common Language Runtime), использующей байткод Intermediate Language (IL).
Он позволяет разработчикам создавать IL код вручную и компилировать его в исполняемый байткод с помощью утилиты компиляции IL\@.



WASM -- это низкоуровневый бинарный формат, предназначенный для исполнения в веб-браузерах.
Binaryen -- это инструментарий для манипулирования и оптимизации байткода WebAssembly.
Он обеспечивает высокую производительность и безопасность и может быть использован для исполнения приложений на различных языках программирования в веб-среде.



В данной работе использование инструмента LLVM для генерации кода на целевую платформу x64 было обусловлено его мощными возможностями и гибкостью.
LLVM предоставляет инфраструктуру для разработки компиляторов и связанных инструментов, включая оптимизатор и генератор машинного кода, способный работать с различными архитектурами процессоров.

\section{Особенности языка Golang}


Программа на Go состоит из пакетов, которые могут быть использованы для организации кода.
Каждый файл программы должен начинаться с объявления пакета.
Подключение пакетов выполняются с помощью ключевого слова import.

Переменные объявляются с использованием ключевого слова var, за которым следует имя переменной и ее тип, либо с помощью оператора краткого объявления :=.

Функции объявляются с использованием ключевого слова func, за которым следует имя функции, список параметров и тип возвращаемого значения (если оно есть).
Функции также могут возвращать несколько значений.

Golang поддерживает стандартные управляющие конструкции, такие как условные операторы if, циклы for, switch и операторы break, continue для управления выполнением программы.

Go включает в себя встроенную поддержку конкурентности с помощью горутин и каналов.
Горутины представляют собой легковесные потоки выполнения, а каналы - механизм для обмена данными между горутинами.

\subsection*{Типизация}

В статически типизированных языках типы данных определяются на этапе компиляции.
Переменные должны быть объявлены с указанием их типа, и этот тип не может быть изменен во время выполнения программы.
Проверка типов происходит на этапе компиляции, что позволяет выявлять множество ошибок ещё до запуска программы.

В динамически типизированных языках типы данных определяются во время выполнения программы.
Переменные могут содержать значения разных типов, и их тип может изменяться во время выполнения программы.
Проверка типов происходит во время выполнения программы, что может приводить к ошибкам во время выполнения, если типы несовместимы.

Статическая типизация обычно обеспечивает более строгую проверку типов, что помогает выявлять ошибки на этапе компиляции, но может потребовать больше времени и усилий от разработчика для объявления и управления типами.
Динамическая типизация обычно обеспечивает более гибкую и удобную работу с типами данных, но может привести к неожиданным ошибкам во время выполнения, особенно в больших и сложных программах.


В языке программирования Golang используется статическая типизация.
В Go типы данных обычно указываются явно при объявлении переменных, функций и других элементов программы.
В Go также поддерживается краткое объявление переменных с использованием оператора \Code{:=}, который автоматически выводит тип переменной на основе значения, с которым она инициализируется.


Go предоставляет разнообразие встроенных типов данных, включая числовые типы (int, float, complex), строковые типы (string), булев тип (bool), указатели (*T), массивы ([n]T), срезы ([]T), карты (map[K]V), структуры (struct) и интерфейсы (interface{}).
В Go можно создавать пользовательские типы данных с помощью ключевого слова type.
Это позволяет абстрагировать сложные структуры данных и создавать собственные абстракции.
В Go у каждого типа данных есть свое нулевое значение.
Например, для числовых типов это 0, для строк это пустая строка, а для указателей это nil.

Интерфейсы в Go определяют набор методов, которые должен реализовать тип данных, чтобы удовлетворить интерфейс.
Это позволяет использовать полиморфизм в коде и обеспечивает гибкость при разработке



\subsection*{Работа с ресурсами}

Golang использует механизм сбора мусора для автоматического управления памятью.
Сборщик мусора следит за использованием объектов и автоматически освобождает память, занимаемую объектами, которые больше не используются.
В данном языке программирования освобождение неиспользуемой памяти запускается автоматически по мере необходимости, когда система обнаруживает, что памяти становится недостаточно или размер кучи увеличился в два раза.
Такой подход позволяет избежать неэффективного использования ресурсов и уменьшает накладные расходы на управление памятью.

В Go можно использовать указатели для явного управления памятью.
Go предоставляет безопасные и удобные абстракции для работы с памятью, что уменьшает риск ошибок и повышает производительность кода.

В Go предусмотрен механизм отложенного выполнения \Code{defer}, который позволяет освобождать ресурсы (например, файлы или сетевые соединения) после завершения работы с ними.
Это помогает избежать утечек ресурсов и обеспечивает эффективное использование системных ресурсов.

\subsection*{Пакеты}

В языке программирования Go пакеты играют важную роль в организации кода и обеспечении его модульности и повторного использования.
Пакет в Go - это набор связанных между собой файлов с исходным кодом, находящихся в одном каталоге.

Существуют два типа пакетов в Go: исполняемые и библиотечные.
Исполняемый пакет представляет собой программу, которая может быть запущена.
Он содержит функцию \Code{main}, с которой начинается выполнение программы.
Библиотечный пакет представляет собой библиотеку кода, предназначенную для повторного использования в других программах.

Для использования функций, типов и переменных из других пакетов необходимо импортировать их в текущий файл с помощью ключевого слова \Code{import}.
При импортировании пакета в Go выполняется его инициализация.
Инициализация выполняется перед выполнением функции `main` в случае исполняемого пакета.

В Go пакеты организованы в виде древовидной структуры.
Имена пакетов должны быть уникальными в пределах пространства имен.
Подкаталоги внутри каталога пакета могут содержать дополнительные пакеты.

В Go принята концепция видимости символов.
Идентификаторы (функции, типы, переменные) считаются видимыми только внутри пакета, если они начинаются с заглавной буквы.
Идентификаторы, начинающиеся с прописной буквы, не доступны извне пакета.

Go поддерживает использование сторонних пакетов, которые не входят в стандартную библиотеку.
Данные пакеты обычно устанавливаются с помощью менеджера зависимостей `go mod`.

\section{Управление памятью}

Управление памятью (как автоматическое, так и ручное) -- это процесс управления памятью.
В частности, существуют две особые проблемы, связанные с управлением памятью:
\begin{enumerate}
    \item предоставлять память по запросу (выделение памяти);
    \item освобождать неиспользуемую память для повторного использования в будущем (освобождение памяти).
\end{enumerate}

Данная проблема является классической в любой операционной системе.
Управление памятью также является фундаментальной проблемой для языков программирования, поскольку они должны автоматически управлять памятью~\cite{bruno2018study}.

\subsection*{Задача сбора мусора}

Задача управления памятью в Golang обрабатывается сборщиком мусора (GC), который отвечает за несколько задач:
\begin{enumerate}
    \item выделять память для новых объектов
    \item следить за тем, чтобы все используемые объекты хранились в памяти
    \item очищать память, которая больше не используется (мусор)
\end{enumerate}

Сборщиком мусора -- это набор алгоритмов, которые скрывают большинство проблем с управлением памятью от языков высокого уровня.
Однако важно отметить, что GC не решает всех проблем с памятью~\cite{appel1989simple}.
Например, ничто не мешает приложению:
\begin{enumerate}
    \item сохранять ссылки на данные, которые больше никогда не будет использоваться;
    \item выделять объекты на неопределенный срок (и сохранять ссылки на все из них) до тех пор, пока не закончится память.
\end{enumerate}

В таких сценариях нет недоступных объектов, и, следовательно, GC не может освободить какую-либо память, что приводит к ошибке нехватки памяти, которая в конечном итоге завершает работу приложения.


Сборщики мусора обладают следующими характеристиками~\cite{gidra2013study}.
\begin{itemize}
    \item Безопасность: cборщик не должен освобождать используемые объекты.
    \item Полнота -- это характеристика показывающая, что весь мусор в конечном итоге будет очищен.
    \item Оперативность -- промежуток времени между появлением мусором и принятием решения о его удалении.
    \item Время паузы -- время необходимое сборщику для определения мусора и его утилизации.
    \item Накладные расходы на пространство -- объем пространства, необходимый для работы сборщика и сохранения дополнительной информации об объектах.
    \item Масштабируемость -- возможность к оперированию большим количеством объектов без снижения производительности приложения.
\end{itemize}


\subsubsection*{Алгоритмы подсчета ссылок}

Как следует из названия, алгоритмы подсчета ссылок (впервые представленные в работе~\cite{collins1960method}) буквально подсчитывают ссылки на объекты.
Такие алгоритмы основаны на следующем инварианте: объект считается живым тогда и только тогда, когда количество ссылок на объект больше нуля.
Следовательно, чтобы иметь возможность узнать, является ли объект живым или нет, алгоритмы подсчета ссылок сохраняют счетчик ссылок для каждого объекта.
Подсчет ссылок считается прямым GC, поскольку он идентифицирует мусор, то есть объекты без входящих ссылок.

\subsubsection*{Алгоритмы трассировки ссылок}

Алгоритмы трассировки ссылок основаны на обходе графа объектов и маркировке достижимых объектов.
Трассировка ссылок довольно проста; объекты, которые отмечены во время трассировки ссылок, считаются живыми.
Все позиции памяти, которые не отмечены, считаются мусором и будут освобождены.
Следовательно, трассировка ссылок считается косвенной GC, то есть она обнаруживает не мусор, а живые объекты~\cite{mccarthy1960recursive}.

Данных подход также называется трехцветной маркировкой, где каждый объект может находиться в одном из следующих состояний:
\begin{itemize}
    \item белый -- начальное состояние;
    \item черный -- у объекта нет исходящих ссылок на белые объекты;
    \item серый -- у объекта есть ссылки на белые объекты.
\end{itemize}

Трехцветная разметка начинается с помещения всех корневых объектов в серый набор, а всех остальных объектов - в белый набор.
Затем алгоритм выполняется следующим образом:
\begin{itemize}
    \item пока в сером наборе есть объекты,
    \begin{itemize}
        \item выбрать один объект из серого набора,
        \item переместить его в черный набор,
        \item поместить все объекты, на которые он ссылается, в серый набор.
    \end{itemize}
\end{itemize}


\section{Формальная постановка задачи}

Необходимо разработать прототип компилятора языка программирования Golang.
Для генерации парсеров и лексеров грамматики языка необходимо использовать ANTLR4.
Для построения IR необходимо использовать библиотеку LLVM.
Для компиляции IR для целевой архитектуры x64 также необходимо использовать LLVM.
На рисунке~\ref{fig:idef-a0} представлена IDEF0 диаграмма компилятора языка программирования Golang.

\begin{figure}[h]
    \centering

    \includesvg[]{plantuml/export/idef-a0}

    \caption{IDEF0 диаграмма компилятора языка программирования Golang}
    \label{fig:idef-a0}
\end{figure}


\section*{Выводы}

В ходе исследования был рассмотрен процесс построения компилятора, включая анализ инфраструктуры и сравнительный анализ инструментов для генерации лексических и синтаксических анализаторов.
Были выявлены особенности типизации, управления ресурсами и организации пакетов в языке программирования Golang.
Также был проведен обзор области управления памятью в контексте разработки компилятора.
В итоге была сформулирована фор мальная задача разработки компилятора для языка Golang.